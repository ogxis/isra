package crawler;

import ICL.ICL;
import isradatabase.Graph;
import isradatabase.Vertex;
import linkProperty.LinkProperty.LP;
import stm.DBCN;
import stm.LTM;
import stm.STMClient;
import utilities.Util;
import ymlDefine.YmlDefine.TaskDetail;

/*
 * Crawler Function Convention is:
 * Without special modifier: stateless calculation. Modifies only given parameter and do not make any transaction to database.
 * TxL: Transaction in code, modify only the parameter fed in. Basically stateless. (LOCAL)
 * TxE: Transaction in code that modify local and expand to external interface. (EXTERNAL)
 * TxF: Transaction in code and lead to next phrase of work, that post states. (FORWARDING)
 */
/**
 * New raw data arrived after being received by general raw data receiver. It create 2 vertex, general and data vertex.
 * Then create edge between them, the vertex we receive here is the general vertex.
 * Job here is just get the distribution value of the data vertex, and create another vertex to store that distValue and create
 * a edge to the general vertex we received here.
 */
public class RawDataDistCacl {
	private long dbErrMaxRetryCount;
	private long dbErrRetrySleepTime;

	public RawDataDistCacl(long dbErrMaxRetryCount, long dbErrRetrySleepTime) {
		this.dbErrMaxRetryCount = dbErrMaxRetryCount;
		this.dbErrRetrySleepTime = dbErrRetrySleepTime;
	}

	public class DistCaclResult {
		String LTMPolyValClassName;
		double distValue;
		boolean ICLRequired;

		public DistCaclResult (String LTMPolyValClassName, double distValue, boolean ICLRequired) {
			this.LTMPolyValClassName = LTMPolyValClassName;
			this.distValue = distValue;
			this.ICLRequired = ICLRequired;
		}
	}

	public DistCaclResult distCaclTxL(Vertex generalVertex, Graph txGraph) {
		/*
		 * To add more raw data type for distribution calculation, follow these:
		 * First you must have the data ported into the STM, and from there it ports to here.
		 * Then you create entries at DBCN for the new raw data type at DBCN.V.general.rawData.YourDataType
		 * In the function add one more clause to check for your data type and calculate dist in there.
		 * Then at the polyVal storing stage the actual class path to store will be already determined during type deduction phrase.
		 */
		//-generalVertex here is raw input data' general vertex.
		//Generated by raw data receiver. We here just add another vertex to it that is scanDist.
		//note: db must be configured to set vertex label as its class name.
		String vertexClass = generalVertex.getCName();

		//dummy values, will be replaced later. Values are all 50 to ensure balancing (50 is middle, equal to contra, no effect) in case of
		//undetected failure, we don't want it to crash too violently during real time service. It is relatively stable for now.
		double scanDist = 50.0;

		//Some operation doesn't need to be ICLed, for example movement data where it is as what it is with no more hidden data within (analog).
		boolean ICLRequired = true;

		//Gather all the required class name during this type deduction phrase.
		String LTMPolyValClassName = "";

		if (Util.equalAny(vertexClass, LTM.VISUAL_RAW)) {
			scanDist = ICL.Visual.scanVisualDistribution(generalVertex);
			LTMPolyValClassName = DBCN.V.LTM.polyVal.rawData.visual.cn;
		}

		else if (Util.equalAny(vertexClass, LTM.AUDIO_RAW)) {
			scanDist = ICL.Audio.scanAudioDistribution(generalVertex);
			LTMPolyValClassName = DBCN.V.LTM.polyVal.rawData.audio.cn;
		}

		//Individual motor. Be noted motor doens't require ICL operation.
		//NOTE: For now motor never gets to here, we had set these values (polyVal) during acquire stage.
		else if (Util.equalAny(vertexClass, LTM.MOVEMENT)) {
			scanDist = ICL.Movement.scanMotorDistribution(generalVertex);
			LTMPolyValClassName = DBCN.V.LTM.polyVal.rawData.movement.cn;
			ICLRequired = false;
		}

		//unknown and unsupported type. break out and restart the loop.
		else {
			throw new IllegalArgumentException("FATAL ERR: Unknown raw data class:" + vertexClass + " in crawler."
					+ " Might be unknown exterior data injection. Expecting className:" + LTM.VISUAL_RAW + ", "
					+ LTM.AUDIO_RAW + " OR " + LTM.MOVEMENT);
		}

		//Commit retry model.
		boolean txError = true;
		int txRetried = 0;
		while (txError) {
			if (txRetried > dbErrMaxRetryCount) {
				throw new IllegalStateException("Failed to complete transaction after number of retry:"
						+ dbErrMaxRetryCount + " with sleep duration of each:" + dbErrRetrySleepTime);
			}
			else if (txError) {
				if (txRetried != 0)
					Util.sleep(dbErrRetrySleepTime);
				txRetried++;
			}
			txGraph.begin();

			generalVertex = Util.vReload(generalVertex, txGraph);

			//Add the dist value to the original general vertex given, so we can calculate and accumulate its dist value in the future
			//when building exp.
			generalVertex.setProperty(LP.polyVal, scanDist);

			//Add dist value to the next phrase 'polyValDistUpdate' at STM where he will use this data to calculate next globalDist.
			//Give him the general class name.
			STMClient.addDist(scanDist, vertexClass, txGraph);

			//store all the dist value including bounds.
			Vertex polyValVertex = txGraph.addVertex(LTMPolyValClassName, LTMPolyValClassName);
			polyValVertex.setProperty(LP.data, scanDist);
			polyValVertex.addEdge(DBCN.E.polyVal, generalVertex);

			txError = txGraph.finalizeTask(true);
		}

		return new DistCaclResult(LTMPolyValClassName, scanDist, ICLRequired);
	}


	public void forwardToICLTxF(Vertex generalVertex, DistCaclResult distCaclResult, Graph txGraph) {
		//Commit retry model.
		boolean txError = true;
		int txRetried = 0;
		while (txError) {
			if (txRetried > dbErrMaxRetryCount) {
				throw new IllegalStateException("Failed to complete transaction after number of retry:"
						+ dbErrMaxRetryCount + " with sleep duration of each:" + dbErrRetrySleepTime);
			}
			else if (txError) {
				if (txRetried != 0)
					Util.sleep(dbErrRetrySleepTime);
				txRetried++;
			}
			txGraph.begin();

			generalVertex = Util.vReload(generalVertex, txGraph);

			if (distCaclResult.ICLRequired) {
				//TODO: Not implemented for now.
				//				//Finalize current task by migrating it to 'completed' state.
				//				Vertex updateToCompletedState = txGraph.addVertex(taskDetail.completedAddr, taskDetail.completedAddr);
				//				updateToCompletedState = Util.copyVertexEdgeAndProperty(taskVertex, updateToCompletedState);

				//Add task to rawDataICL which compute patterns from raw data. ICL is responsible to deduce the type on its own later.
				Vertex ICLTaskVertex = txGraph.addVertex(DBCN.V.jobCenter.crawler.rawDataICL.task.cn, DBCN.V.jobCenter.crawler.rawDataICL.task.cn);
				Vertex ICLTaskDetailVertex = txGraph.addVertex(DBCN.V.taskDetail.cn, DBCN.V.taskDetail.cn);
				ICLTaskVertex.addEdge(DBCN.E.source, ICLTaskDetailVertex);

				TaskDetail ICLTaskDetail = new TaskDetail();
				ICLTaskDetail.jobId = "-1";
				ICLTaskDetail.jobType = CRAWLERTASK.rawDataICL;
				ICLTaskDetail.source = "";
				ICLTaskDetail.processingAddr = DBCN.V.jobCenter.crawler.rawDataICL.processing.cn;
				ICLTaskDetail.completedAddr = DBCN.V.jobCenter.crawler.rawDataICL.completed.cn;
				ICLTaskDetail.replyAddr = DBCN.V.devnull.cn;
				ICLTaskDetail.start = -1;
				ICLTaskDetail.end = -1;
				ICLTaskDetailVertex.addEdge(DBCN.E.source, generalVertex);
				ICLTaskDetailVertex.setProperty(LP.data, Util.kryoSerialize(ICLTaskDetail) );
			}

			txError = txGraph.finalizeTask(true);
		}

		//Start a new transaction to avoid retry induced data inconsistency at GCA site. To guarantee idempotent.
		txGraph.begin();
		//Add the data to GCA for archive purpose only (offline analysis) as raw data will no longer be used anyway.
		STMClient.rawDataAddToGCAQueue(generalVertex, txGraph);
		txGraph.finalizeTask();
	}
}